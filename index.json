[
{
	"uri": "https://doc.notapplicable.info/getting-started/cloning_this_repository_and_regenerating_the_site_locally/",
	"title": "Cloning this site and regenerating locally on your own machine",
	"tags": [],
	"description": "",
	"content": "Prerequisites to download the site and push it back to the same or other repositories you need Git.\nIf you dont already have Git, it can be downloaded from https://git-scm.com/downloads\nto rebuild or preiview the site you need hugo in your path. It is a single executable with no installer, just copy the binary somewhere like (for windows) \u0026lsquo;c:\\program files\u0026lt;some directory of your choice\u0026gt; and add it to your system path in System Properties - Environment_variables if it is not already or (for Linux / Mac) /usr/local/bin.\nHugo can be downloaded from hugo releases\nCopy / clone the site This site is hosted at https://marshyon.github.io/.\nClone it to somewhere appropriate on your system with :\ngit clone https://github.com/marshyon/marshyon.github.io.git cd marshyon.github.io.git/hugo/themes/hugo-theme-learn git submodule init git submodule update cd ../../ Edit content open the directory and edit the files in\nhugo/content Previewing changes from within the hugo/content directory run hugo serve -b http://localhost:1313 to serve the content locally\nRebuild the site post to making changes To regenerate the site with new content in hugo/content from a command line window and within the hugo directory run :\nhugo I you don\u0026rsquo;t want to add hugo to your path, it can be run from the place you downloaded and uncompressed it to, for example in windows :\nC:\\Users\\\u0026lt;your user\u0026gt;\\Downloads\\hugo_0.78.0_Windows-64bit\\hugo.exe Publishing changes back to Github If you have access to push back to the marshyon account in which this site is hosted, just push changes back with\ngit push Changing the site to be used in your own git repo If your wanting to use this repository for your own site, replace with your content in hugo/content and edit config.toml accordingly to suit your intended site name\nin .git/content' ( at the root folder of this repository directory ) edit the config` file and change the section\n[remote \u0026quot;origin\u0026quot;] url = https://\u0026lt;your remote git repository here\u0026gt;.git to have the url of your git repository and then push to it with git push\n"
},
{
	"uri": "https://doc.notapplicable.info/articles/devops/",
	"title": "Devops",
	"tags": [],
	"description": "",
	"content": "Chapter X DevOps A variety of articles releated to Devops\n"
},
{
	"uri": "https://doc.notapplicable.info/",
	"title": "Home",
	"tags": [],
	"description": "",
	"content": "Documentation This is our starter for 10 documentation site. It uses Hugo and the Learn theme.\nDocumentation Summary  Getting Started with Hugo  Chapter 1 Getting Started with Hugo Static Site Generator Build a documentation website for your service using Hugo and hugo-theme-learn in less than an hour.\n Cloning this site and regenerating locally on your own machine  Prerequisites to download the site and push it back to the same or other repositories you need Git. If you dont already have Git, it can be downloaded from https://git-scm.com/downloads to rebuild or preiview the site you need hugo in your path. It is a single executable with no installer, just copy the binary somewhere like (for windows) \u0026lsquo;c:\\program files\u0026lt;some directory of your choice\u0026gt; and add it to your system path in System Properties - Environment_variables if it is not already or (for Linux / Mac) /usr/local/bin.\n Installation  The following steps are here to help you initialize your new website. If you don\u0026rsquo;t know Hugo at all, we strongly suggest you learn more about it by following this great documentation for beginners. Create your project Hugo provides a new command to create a new website. hugo new site \u0026lt;new_project\u0026gt; Install the theme Install the Hugo-theme-learn theme by following this documentation This theme\u0026rsquo;s repository is: https://github.com/matcornic/hugo-theme-learn.git Alternatively, you can download the theme as .\n Publishing a Hugo Site to Github Io  Setting up your Github account To publish to github.io for free, you need to have a current public Github account. Mine is already created under the username of marshyon so this is the name I used to publish this site under. A github.io account is available to all Github account users with their username as subdomain to github.io, for example: https://marshyon.github.io so you will, when activated have access to your content from a similar url but with your username in place of marshyon of course.\n Articles  Chapter 2 Collected Articles Articles on a variety of things, mostly technical, some comentary but centering on the current state of IT, Systems Administraton, Cloud, Developement and DevOps\n Devops  Chapter X DevOps A variety of articles releated to Devops\n Contribute to this documentation Feel free to fork this repository and submit pull requests.\n"
},
{
	"uri": "https://doc.notapplicable.info/getting-started/installation/",
	"title": "Installation",
	"tags": [],
	"description": "",
	"content": "The following steps are here to help you initialize your new website. If you don\u0026rsquo;t know Hugo at all, we strongly suggest you learn more about it by following this great documentation for beginners.\nCreate your project Hugo provides a new command to create a new website.\nhugo new site \u0026lt;new_project\u0026gt; Install the theme Install the Hugo-theme-learn theme by following this documentation\nThis theme\u0026rsquo;s repository is: https://github.com/matcornic/hugo-theme-learn.git\nAlternatively, you can download the theme as .zip file and extract it in the themes directory\nBasic configuration When building the website, you can set a theme by using --theme option. However, we suggest you modify the configuration file (config.toml) and set the theme as the default. You can also add the [outputs] section to enable the search functionality.\n# Change the default theme to be use when building the site with Hugo theme = \u0026#34;hugo-theme-learn\u0026#34; # For search functionality [outputs] home = [ \u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;, \u0026#34;JSON\u0026#34;] Create your first chapter page Chapters are pages that contain other child pages. It has a special layout style and usually just contains a chapter name, the title and a brief abstract of the section.\n### Chapter 1 # Basics Discover what this Hugo theme is all about and the core concepts behind it. renders as\nHugo-theme-learn provides archetypes to create skeletons for your website. Begin by creating your first chapter page with the following command\nhugo new --kind chapter basics/_index.md By opening the given file, you should see the property chapter=true on top, meaning this page is a chapter.\nBy default all chapters and pages are created as a draft. If you want to render these pages, remove the property draft: true from the metadata.\nCreate your first content pages Then, create content pages inside the previously created chapter. Here are two ways to create content in the chapter:\nhugo new basics/first-content.md hugo new basics/second-content/_index.md Feel free to edit thoses files by adding some sample content and replacing the title value in the beginning of the files.\nLaunching the website locally Launch by using the following command:\nhugo serve Go to http://localhost:1313\nYou should notice three things:\n You have a left-side Basics menu, containing two submenus with names equal to the title properties in the previously created files. The home page explains how to customize it by following the instructions. When you run hugo serve, when the contents of the files change, the page automatically refreshes with the changes. Neat!  Build the website When your site is ready to deploy, run the following command:\nhugo A public folder will be generated, containing all static content and assets for your website. It can now be deployed on any web server.\nThis website can be automatically published and hosted with Netlify (Read more about Automated HUGO deployments with Netlify). Alternatively, you can use Github pages\n "
},
{
	"uri": "https://doc.notapplicable.info/getting-started/",
	"title": "Getting Started with Hugo",
	"tags": [],
	"description": "",
	"content": "Chapter 1 Getting Started with Hugo Static Site Generator Build a documentation website for your service using Hugo and hugo-theme-learn in less than an hour.\n"
},
{
	"uri": "https://doc.notapplicable.info/getting-started/publishing-a-hugo-site-to-github-io/",
	"title": "Publishing a Hugo Site to Github Io",
	"tags": [],
	"description": "",
	"content": "Setting up your Github account To publish to github.io for free, you need to have a current public Github account. Mine is already created under the username of marshyon so this is the name I used to publish this site under. A github.io account is available to all Github account users with their username as subdomain to github.io, for example:\nhttps://marshyon.github.io so you will, when activated have access to your content from a similar url but with your username in place of marshyon of course.\nTo activate this functionality, create a new public repository in your Github account :\nso Repository name needs to be like the following :\n\u0026lt;your_git_user_account_name\u0026gt;.github.io so I created one like this :\nmarshyon.github.io now I have my content available at\nhttps://marshyon.github.io Any content ( html, css, javascript, jpg, png etc \u0026hellip; ) that gets commited to your newly created repository will then automatically appear at your_gith_user_name.github.io address\nThere can be a time lag between your pushing your additions / changes to github of up to 20 minutes - accourding to Githubs own documentation so dont expect things to appear straight away, although they might, depenindg upon Githubs own current work loads. This is only fair in my view, after all, this is a free service so we cant really complain.\nConfigure Hugo for use in Github.io hosting Create a new directory structure to host your new git account with the following :\n. ├── hugo_site └── README.md where hugo_site is a directory that will hold your hugo site and README.md contains a description of your site and project\nInitialise your git repository locally following the instructions given by github when you created the new repository.\nCopy or move the hugo site you created with getting started installation into the hugo_site directory.\nHugo uses a config.toml file to configure the creation of your static site so this needs to be changed to have the following values :\nbaseURL = \u0026quot;https://your_git_user_name.github.io\u0026quot; publishDir = \u0026quot;..\u0026quot; replacing your_git_user_name with your own git user name\nensure that all of your hugo pages have\ndraft: false in their meta data or have this line removed then change directory to your hugo_site directory and run :\nhugo You should find that your site code is generated in the directory above hugo_site.\nCommit to git your additions and changes then push the git content to see the site available at github.io.\nWorking with new content the following can be used to run a dynamically loaded site on localhost port 1313 :\nhugo serve -b http://localhost:1313 This over rides the github address now in config.toml and permits you to preview changes before again running hugo to update / git commit and push your generated content.\n"
},
{
	"uri": "https://doc.notapplicable.info/articles/",
	"title": "Articles",
	"tags": [],
	"description": "",
	"content": "Chapter 2 Collected Articles Articles on a variety of things, mostly technical, some comentary but centering on the current state of IT, Systems Administraton, Cloud, Developement and DevOps\n"
},
{
	"uri": "https://doc.notapplicable.info/articles/devops/exposing_k8s_pods_to_the_outside/",
	"title": "Exposing Pods in K8s to the outside world",
	"tags": [],
	"description": "",
	"content": "Simple single pod deploy and exposure of service outside of K8s using a simple test nodejs docker container at :\nhttps://hub.docker.com/r/marshyon/test-node-container\nlets create a running pod using a pre-configured application from docker hub:\nkubectl run node-test --image=marshyon/test-node-container --port=8080 this can be seen to be running within k8s by getting pods in the default namespace :\nkubectl get pods NAME READY STATUS RESTARTS AGE node-test 1/1 Running 0 9m57s to expose this to the outside world we need to expose it using a load balancer :\nkubectl expose pod node-test --port=8080 --name=frontend --type=LoadBalancer service/frontend exposed to find out where it is now available we can list the clusters running services :\nkubectl get service NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE frontend LoadBalancer 10.3.241.8 35.189.125.205 8080:31713/TCP 71s kubernetes ClusterIP 10.3.240.1 \u0026lt;none\u0026gt; 443/TCP 25m and to smoke test the service we can curl to it with :\ncurl http://35.189.125.205:8080 You've hit node-test Using a deployment to create a replica set and exposure outside of K8s with LoadBalancer the following deployment.yaml file can be used to create a replica set of \u0026lsquo;node-test-apps\u0026rsquo; that can be edited and redeployed.\napiVersion: apps/v1 kind: Deployment metadata: name: node-test-deployment labels: app: node-test-label spec: replicas: 10 selector: matchLabels: app: node-test-label template: metadata: labels: app: node-test-label spec: containers: - name: node-test-app image: marshyon/test-node-container ports: - containerPort: 8080 to apply this file :\nkubectl apply -f deployment.yaml this will create a replica set within a deployment - the identifier \u0026lsquo;label\u0026rsquo; of node-test-label being used to link all of the 10 replicas\nkubectl get pods will list 10 running pods\nthis deployment can now be exposed using a service of type LoadBalancer :\nkubectl expose -f deployment.yaml --port=8080 --target-port=8080 --type=LoadBalancer the service is created and can be seen with\nkubectl get service NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE kubernetes ClusterIP 10.3.240.1 \u0026lt;none\u0026gt; 443/TCP 2m58s node-test-deployment LoadBalancer 10.3.254.125 34.105.188.22 8080:32055/TCP 39s and tested with\ncurl http://34.105.188.22:8080 You've hit node-test-deployment-7745697756-thg6k Editing and re-applying a deployment the above yaml file can be edited to have less or more replicas and re-applied with\nkubectl apply -f deployment.yaml and the 10 replicas ( here edited to be 3 ) can be seen as :\nkubectl get pods NAME READY STATUS RESTARTS AGE node-test-deployment-7745697756-7s8pv 1/1 Terminating 0 3m4s node-test-deployment-7745697756-cxglf 1/1 Running 0 3m5s node-test-deployment-7745697756-fq6f8 1/1 Terminating 0 3m4s node-test-deployment-7745697756-h49mk 1/1 Terminating 0 3m4s node-test-deployment-7745697756-p76z6 1/1 Running 0 3m4s node-test-deployment-7745697756-pf6ch 1/1 Terminating 0 3m5s node-test-deployment-7745697756-ptd7x 1/1 Terminating 0 3m5s node-test-deployment-7745697756-rvfl2 1/1 Terminating 0 3m4s node-test-deployment-7745697756-thg6k 1/1 Running 0 3m4s node-test-deployment-7745697756-vfktd 1/1 Terminating 0 3m4s after some time :\nkubectl get pods NAME READY STATUS RESTARTS AGE node-test-deployment-7745697756-cxglf 1/1 Running 0 6m15s node-test-deployment-7745697756-p76z6 1/1 Running 0 6m14s node-test-deployment-7745697756-thg6k 1/1 Running 0 6m14s "
},
{
	"uri": "https://doc.notapplicable.info/articles/devops/deploying_kubernetes_clusters_with_different_cloud_providers/",
	"title": "Deploying Kubernetes Clusters to Cloud Providers",
	"tags": [],
	"description": "",
	"content": "K8s in any cloud platform is essentially just K8s, in that that it is still fundamentally Kubernetes \u0026lsquo;under the hood\u0026rsquo;. However there are different ways in which to deploy K8s in AWS for example as opposed to Azure, Google cloud and others.\nWhen exposing services to the internet or rather, network sources outside that of the cluster, there are differences brought about by the way the prevailing service integrates with said exposure. Azure, Amazon and Google all have their own \u0026lsquo;Ingress\u0026rsquo; load balancer integrations. We are not entirely limited to the the stock provision from each provider. For example Nginx offers an alternative Ingress load balancer solution that runs as a service within the cluster as do those provided by the big 3 and others. So we have lots of options however in the simplest form, each provider has an Ingress and integration layer that creates a load balancer outside of the cluster that is specific to each cloud platform.\nPrerequisites for K8s and Terraform kubectl\ncurl -LO \u0026quot;https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl\u0026quot; chmod +x ./kubectl sudo mv kubectl /usr/local/bin terraform\nThis is only required if you want to use terraform (ofcourse)\ndownload terraform zip file from https://www.terraform.io/downloads.html\nunzip /mnt/c/Users/jon/Downloads/terraform_0.13.5_linux_amd64.zip sudo mv terraform /usr/local/bin/terraform AWS Prerequisites for AWS I\u0026rsquo;ve found that implementing K8s using command line tools such as Terraform using Linux to do so gives me best results but this is my opinion having worked on Linux for \u0026gt; 10 years and being entirely happy with bash which most K8s howtos use. Windows WSL is an adequate Linux environment for this so Windows users are in no way out of options. Mac users are all cool, so they can handle anything. If your using Linux as your core OS there nees nothing more to be said.\naws and eksctl\nexample of aws cli install :\ncurl \u0026quot;https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip\u0026quot; -o \u0026quot;awscliv2.zip\u0026quot; unzip awscliv2.zip sudo ./aws/install To allow aws cli to function you need to run aws configiure which will ask for a key, secret which is the minimum required to function. A default location and output format ( for example eu-west-2 and json ).\nGet an access key / secret key pair from the AWS console under IAM and search ofr \u0026lsquo;your security credentials\u0026rsquo;.\nexample eksctl install :\ncurl --silent --location \u0026quot;https://github.com/weaveworks/eksctl/releases/latest/download/eksctl_$(uname -s)_amd64.tar.gz\u0026quot; | tar xz -C /tmp sudo mv /tmp/eksctl /usr/local/bin for the latest instructions see https://docs.aws.amazon.com/eks/latest/userguide/getting-started-eksctl.html\naws-iam-authenticator\nOnly needed if you want to use Terraform to build the cluster. Without this Terraform builds will fail. Terraform, I believe specifically the aws plugin that terraform installs needs to have this but I could be mistaken.\nHere is an example install :\ncurl -o aws-iam-authenticator https://amazon-eks.s3.us-west-2.amazonaws.com/1.18.8/2020-09-18/bin/linux/amd64/aws-iam-authenticator chmod +x ./aws-iam-authenticator sudo mv aws-iam-authenticator /usr/local/bin for the latest installation see https://docs.aws.amazon.com/eks/latest/userguide/install-aws-iam-authenticator.html\nList Clusters in AWS We need an easy way to know if there are clusters already created in our account. Heres a quick way to get that information :\naws eks list-clusters { \u0026quot;clusters\u0026quot;: [] } In this example, there are no clusters. This is good as at this point nothing is deployed\nCreate an AWS K8s cluster with eksctl a cluster in AWS can be created with a single command :\n eksctl create cluster \\ --name myk8s-cluster \\ --node-type t2.micro \\ --nodes 3 \\ --nodes-min 3 \\ --nodes-max 5 \\ --region eu-west-2 This can take some time to complete. Often over 10 minutes so be prepared to wait.\nDelete the AWS K8s cluster with eksctl eksctl delete cluster --name myk8s-cluster --region eu-west-2 Create an AWS K8s with Terraform with a file called for example main.tf\nprovider \u0026quot;aws\u0026quot; { region = \u0026quot;eu-west-2\u0026quot; } data \u0026quot;aws_eks_cluster\u0026quot; \u0026quot;cluster\u0026quot; { name = module.eks.cluster_id } data \u0026quot;aws_eks_cluster_auth\u0026quot; \u0026quot;cluster\u0026quot; { name = module.eks.cluster_id } provider \u0026quot;kubernetes\u0026quot; { host = data.aws_eks_cluster.cluster.endpoint cluster_ca_certificate = base64decode(data.aws_eks_cluster.cluster.certificate_authority.0.data) token = data.aws_eks_cluster_auth.cluster.token load_config_file = false version = \u0026quot;~\u0026gt; 1.11\u0026quot; } data \u0026quot;aws_availability_zones\u0026quot; \u0026quot;available\u0026quot; { } locals { cluster_name = \u0026quot;my-cluster\u0026quot; } module \u0026quot;vpc\u0026quot; { source = \u0026quot;terraform-aws-modules/vpc/aws\u0026quot; version = \u0026quot;2.47.0\u0026quot; name = \u0026quot;k8s-vpc\u0026quot; cidr = \u0026quot;172.16.0.0/16\u0026quot; azs = data.aws_availability_zones.available.names private_subnets = [\u0026quot;172.16.1.0/24\u0026quot;, \u0026quot;172.16.2.0/24\u0026quot;, \u0026quot;172.16.3.0/24\u0026quot;] public_subnets = [\u0026quot;172.16.4.0/24\u0026quot;, \u0026quot;172.16.5.0/24\u0026quot;, \u0026quot;172.16.6.0/24\u0026quot;] enable_nat_gateway = true single_nat_gateway = true enable_dns_hostnames = true public_subnet_tags = { \u0026quot;kubernetes.io/cluster/${local.cluster_name}\u0026quot; = \u0026quot;shared\u0026quot; \u0026quot;kubernetes.io/role/elb\u0026quot; = \u0026quot;1\u0026quot; } private_subnet_tags = { \u0026quot;kubernetes.io/cluster/${local.cluster_name}\u0026quot; = \u0026quot;shared\u0026quot; \u0026quot;kubernetes.io/role/internal-elb\u0026quot; = \u0026quot;1\u0026quot; } } module \u0026quot;eks\u0026quot; { source = \u0026quot;terraform-aws-modules/eks/aws\u0026quot; version = \u0026quot;12.2.0\u0026quot; cluster_name = local.cluster_name cluster_version = \u0026quot;1.17\u0026quot; subnets = module.vpc.private_subnets vpc_id = module.vpc.vpc_id node_groups = { first = { desired_capacity = 4 max_capacity = 10 min_capacity = 3 instance_type = \u0026quot;t2.micro\u0026quot; } } write_kubeconfig = true config_output_path = \u0026quot;./\u0026quot; } from within the directory that contains main.tf :\nterraform init terraform plan terraform apply if successful, the above will create a credentials file within the same directory which may be used to then authenticate against the K8s cluster :\nexport KUBECONFIG=\u0026quot;${PWD}/kubeconfig_my-cluster\u0026quot; kubectl get pods --all-namespaces and this should firstly create the environment variable KUBECONFIG, recognised by kubectl to contain the location of the credentials file and secondly list all pods in all namespaces\nDelete the AWS K8s cluster with Terraform To delete the K8s cluster created with Terraform, in the same directory as terraform apply command was executed :\nterraform destroy Google Cloud Prerequisites for Google Cloud follow installation instructions to install gcloud command line interface at :\nhttps://cloud.google.com/sdk/docs/install\nInitialize Google Cloud Environment From the Google Cloud console, create a project then initialize Google Cloud command line environment to use it with :\ngcloud init Create cluster with gcloud gcloud container clusters create kubia --num-nodes 3 --machine-type e2-small Delete cluster with gcloud gcloud container clusters delete kubia References https://learnk8s.io/terraform-eks\nhttps://www.manning.com/books/kubernetes-in-action\n"
},
{
	"uri": "https://doc.notapplicable.info/articles/devops/deploy-a-go-web-service-as-an-azure-web-application-using-docker/",
	"title": "Deploy a Go Web Service as an Azure Web Application Using Docker",
	"tags": [],
	"description": "",
	"content": "Azure Web Applications can only support a limited number of languages and whilst Go was supported for a time it is no longer so as an alternative is to serve a custom Docker image with a Go web application within it, hosted on a public registry such as Docker Hub or a private one within Azure itself. The following focuses on the use of a private registry hosted in Azure.\nTo follow the procedure outlined below the following prerequisites will need to be installed :\n Docker azure cli Go  Pretty much all that follows is run from a bash shell under Linux, Mac or Ubuntu sub system for windows. The command \u0026lsquo;jq\u0026rsquo; will be used and if it is not already installed it will also be needed :\nsudo apt install jq With the az command installed, it is also assumed that there is already an Azure account available and that this is authenticated and ready to use with\naz login The following is the server.go file\npackage main import ( \u0026quot;context\u0026quot; \u0026quot;fmt\u0026quot; \u0026quot;log\u0026quot; \u0026quot;net/http\u0026quot; \u0026quot;os\u0026quot; \u0026quot;os/signal\u0026quot; \u0026quot;syscall\u0026quot; \u0026quot;time\u0026quot; \u0026quot;github.com/gorilla/mux\u0026quot; \u0026quot;gopkg.in/natefinch/lumberjack.v2\u0026quot; ) func handler(w http.ResponseWriter, r *http.Request) { query := r.URL.Query() name := query.Get(\u0026quot;name\u0026quot;) if name == \u0026quot;\u0026quot; { name = \u0026quot;Guest\u0026quot; } log.Printf(\u0026quot;Received request for %s\\n\u0026quot;, name) w.Write([]byte(fmt.Sprintf(\u0026quot;Hello, %s\\n\u0026quot;, name))) } func main() { // Create Server and Route Handlers r := mux.NewRouter() r.HandleFunc(\u0026quot;/\u0026quot;, handler) srv := \u0026amp;http.Server{ Handler: r, Addr: \u0026quot;:8080\u0026quot;, ReadTimeout: 10 * time.Second, WriteTimeout: 10 * time.Second, } // Configure Logging LOG_FILE_LOCATION := os.Getenv(\u0026quot;LOG_FILE_LOCATION\u0026quot;) if LOG_FILE_LOCATION != \u0026quot;\u0026quot; { log.SetOutput(\u0026amp;lumberjack.Logger{ Filename: LOG_FILE_LOCATION, MaxSize: 500, // megabytes MaxBackups: 3, MaxAge: 28, //days Compress: true, // disabled by default }) } // Start Server go func() { log.Println(\u0026quot;Starting Server\u0026quot;) if err := srv.ListenAndServe(); err != nil { log.Fatal(err) } }() // Graceful Shutdown waitForShutdown(srv) } func waitForShutdown(srv *http.Server) { interruptChan := make(chan os.Signal, 1) signal.Notify(interruptChan, os.Interrupt, syscall.SIGINT, syscall.SIGTERM) // Block until we receive our signal. \u0026lt;-interruptChan // Create a deadline to wait for. ctx, cancel := context.WithTimeout(context.Background(), time.Second*10) defer cancel() srv.Shutdown(ctx) log.Println(\u0026quot;Shutting down\u0026quot;) os.Exit(0) } The following is the Dockerfile which will be used to build a new docker image based on the Go application above\nFROM golang:latest as builder # Add Maintainer Info LABEL maintainer=\u0026quot;Jon Brookes \u0026lt;marshyon@gmail.com\u0026gt;\u0026quot; # Set the Current Working Directory inside the container WORKDIR /app # Copy go mod and sum files COPY go.mod go.sum ./ # Download all dependencies. Dependencies will be cached if the go.mod and go.sum files are not changed RUN go mod download # Copy the source from the current directory to the Working Directory inside the container COPY . . # Build the Go app RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o main FROM alpine:latest RUN apk --no-cache add ca-certificates WORKDIR /root/ # Copy the Pre-built binary file from the previous stage COPY --from=builder /app/main . # Expose port 8080 to the outside world EXPOSE 8080 # Command to run the executable CMD [\u0026quot;./main\u0026quot;] Here is the directory structure for the above files:\ngo-docker-app/ ├── Dockerfile └── server.go Create the above directory, cd into it, create the Dockerfile and server.go files as above and run :\ncd go-docker go mod init github.com/\u0026lt;your github name\u0026gt;/go-docker-app go build A docker image is then built with :\ndocker build -t go-web-app . The following deploy.sh script creates an Azure Web Application that serves our docker image ( ensure that the word uniquename is replaced with something unique and reflective of the intended application ) :\n#!/usr/bin/bash # replace 'uniquename' with your own unique name # define variables for repeated use in the current script export RESOURCE_GROUP=\u0026quot;uniquenameResourceGroup\u0026quot; export AZURE_REGISTRY_NAME=\u0026quot;uniquenameRegisry\u0026quot; export DOCKER_IMAGE_NAME=\u0026quot;uniquename-custom-docker-image\u0026quot; export DOCKER_IMAGE_TAG=\u0026quot;v1.0.0\u0026quot; export APP_SERVICE_PLAN_NAME=\u0026quot;uniquenameAppServicePlan\u0026quot; export APP_NAME=\u0026quot;uniquenameApplicaton\u0026quot; # this will need to be unique export APP_PORT=\u0026quot;8080\u0026quot; # this is the port number our docker image is configured to listen on # build our docker image docker build -t ${DOCKER_IMAGE_NAME} . # create a resource group into which we can store resources pertinent to this activity az group create --name ${RESOURCE_GROUP} --location \u0026quot;UK South\u0026quot; # create a private registry in order to store our docker image az acr create --name ${AZURE_REGISTRY_NAME} \\ --resource-group ${RESOURCE_GROUP} --sku Basic \\ --admin-enabled true # in order to authenticate against our newly created registry, get user name and password for this CREDENTIAL_JSON=$(az acr credential show --name ${AZURE_REGISTRY_NAME}) # the output of the credential show command will be in json format and we need to extract # - passwords .. value ( the first or second it doesn't matter which # - username ( this will be the registry name ) # the following jq commands will do this for us export REGISTRY_USERNAME=$(echo ${CREDENTIAL_JSON} | jq -r '.username') export REGISTRY_PASSWORD=$(echo ${CREDENTIAL_JSON} | jq -r \u0026quot;[.passwords][0][0]|.value\u0026quot;) # now we authenticate against our newly created docker registry docker login ${AZURE_REGISTRY_NAME}.azurecr.io --username ${REGISTRY_USERNAME} --password ${REGISTRY_PASSWORD} # tag our recently created custom docker image docker tag ${DOCKER_IMAGE_NAME} ${AZURE_REGISTRY_NAME}.azurecr.io/${DOCKER_IMAGE_NAME}:${DOCKER_IMAGE_TAG} # push our tagged image to our private registry docker push ${AZURE_REGISTRY_NAME}.azurecr.io/${DOCKER_IMAGE_NAME}:${DOCKER_IMAGE_TAG} # list our docker images az acr repository list -n ${AZURE_REGISTRY_NAME} # create an Azure App Service Plan az appservice plan create --name ${APP_SERVICE_PLAN_NAME} \\ --resource-group ${RESOURCE_GROUP} --sku B1 --is-linux # create the web app into which we will deploy our container az webapp create --resource-group ${RESOURCE_GROUP} \\ --plan ${APP_SERVICE_PLAN_NAME} --name ${APP_NAME} \\ --deployment-container-image-name ${AZURE_REGISTRY_NAME}.azurecr.io/${DOCKER_IMAGE_NAME}:${DOCKER_IMAGE_TAG} # give the application credentials which it will need to log in to our private registry az webapp config container set --name ${APP_NAME} \\ --resource-group ${RESOURCE_GROUP} \\ --docker-custom-image-name ${AZURE_REGISTRY_NAME}.azurecr.io/${DOCKER_IMAGE_NAME}:${DOCKER_IMAGE_TAG} \\ --docker-registry-server-url https://${AZURE_REGISTRY_NAME}.azurecr.io \\ --docker-registry-server-user ${REGISTRY_USERNAME} \\ --docker-registry-server-password ${REGISTRY_PASSWORD} # configure environment variables for the docker instance az webapp config appsettings set --resource-group ${RESOURCE_GROUP} --name ${APP_NAME} --settings WEBSITES_PORT=${APP_PORT} The application should now be available at\nhttp://${APP_NAME}.azurewebsites.net References :  Building Docker Containers for Go Applications Tutorial: Build a custom image and run in App Service from a private registry  "
},
{
	"uri": "https://doc.notapplicable.info/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://doc.notapplicable.info/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]