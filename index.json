[
{
	"uri": "https://marshyon.github.io/marshyon/articles/devops/",
	"title": "Devops",
	"tags": [],
	"description": "",
	"content": " Chapter X DevOps A variety of articles releated to Devops\n"
},
{
	"uri": "https://marshyon.github.io/marshyon/articles/commentary/c19/",
	"title": "Outbreak",
	"tags": [],
	"description": "",
	"content": " Corona 19 Perhaps the worst viral outbreak since so called Spanish Flu of the post first world war era has reared its ugly head and torn through everyones lives, families, life styles, welfare and our very existence.\nWhat will this mean for us now and in the future, we will only know in time but for certain, we should never go back to the way of doing things before the virus outbreak as if nothing ever happened, assuming a business as normal approach. Nothing will be the same again.\n"
},
{
	"uri": "https://marshyon.github.io/marshyon/getting-started/",
	"title": "Getting Started with Hugo",
	"tags": [],
	"description": "",
	"content": " Chapter 1 Getting Started with Hugo Static Site Generator Build a documentation website for your service using Hugo and hugo-theme-learn in less than an hour.\n"
},
{
	"uri": "https://marshyon.github.io/marshyon/articles/commentary/",
	"title": "Comentary",
	"tags": [],
	"description": "",
	"content": " Chapter 2.2 Comentary General comments, thoughts and ideas on the state of the amazing world of IT we live in\n"
},
{
	"uri": "https://marshyon.github.io/marshyon/articles/commentary/amazing-place-to-be/",
	"title": "Its an Amazing Place to Be",
	"tags": [],
	"description": "",
	"content": " 2020 In this year we find ourselves in a tremendously new, unfamiliar, strange, sometimes confusing and even exciting new world of technology and directions that once only a few years ago would seem impossible even implausable.\nOver 20 years ago I started to specialise in open source, specifically Linux based services and systems. I did this as I refuse to use pirated software and although I have no objection to using and paying for licensed software, I could not at the time justify the high cost of commercial software supplied by the likes of Microsoft and other giants.\nToday and over the recent weeks / months I have spent an increasingly longer time using Microsoft web based documentation which features not windows software but Azure hosted open source tools and materials.\nAll that time ago, and starting out as a systems administrator the organisations I worked for did not allocate much if any budget to the function I performed so asking for a few hundred quid ( uk pounds ) to purchase a license for some suite of tools just so I could learn pascal was not going to happen.\nThere was then an environment of fear uncertainty and doubt surrounding open source and indeed a general mood of contempt for such things from Microsoft and others in the industry.\nSo blow it, I chose open source and have not looked back. I can’t say I’ve loved every moment of it since but learning was frankly easier, particularly as all of the software I needed was free to use under open source license and also as from the early days back in 1990 something you could get information freely on open source software and tools that you wanted to learn. Meantime Microsoft and others were charging considerable amounts of cash for training materials and documentation.\nI’m not intending to bash on Microsoft, even though they surely deserve it for the bad things they have done to the Linux community in the past but I’m not interested in getting the final word either. I am now as before, a pragmatist and will use the right tools for the right job and at the right cost.\nHow things have changed though, now Microsoft ‘loves Linux’ and if we don’t want to believe that, Azure it is said hosts over 60% Linux based servers and applications. On a recent project I’ve worked on, dotnet core developers were delivering C# code compiled on Linux based pipelines and hosted as Linux web applications. The ‘dotnet core’ application platform they inform me is moving further away from traditional .NET than ever before, soon to have little or no backwards compatibility with it’s Windows roots.\nAt a recent Microsoft training event that I attended we were presented for a whole day with tools hosted on Azure that are wholly Linux based solutions, Kubernetes, Docker, I even saw a Microsoft person using Vim.\nAnd I could go on. It would seem that the recent turn around of Microsoft’s financial status would coincide with their new direction and possibly new CEO Satya Nadella who took over from Steve Ballmer in 2014. I wonder what Steve and Bill think of what he’s done and if they’ve changed their minds on certain things now ?\n"
},
{
	"uri": "https://marshyon.github.io/marshyon/articles/",
	"title": "Articles",
	"tags": [],
	"description": "",
	"content": " Chapter 2 Collected Articles Articles on a variety of things, mostly technical, some comentary but centering on the current state of IT, Systems Administraton, Cloud, Developement and DevOps\n"
},
{
	"uri": "https://marshyon.github.io/marshyon/articles/devops/deploy-a-go-web-service-as-an-azure-web-application-using-docker/",
	"title": "Deploy a Go Web Service as an Azure Web Application Using Docker",
	"tags": [],
	"description": "",
	"content": " Azure Web Applications can only support a limited number of languages and whilst Go was supported for a time it is no longer so as an alternative is to serve a custom Docker image with a Go web application within it, hosted on a public registry such as Docker Hub or a private one within Azure itself. The following focuses on the use of a private registry hosted in Azure.\nTo follow the procedure outlined below the following prerequisites will need to be installed :\n Docker azure cli Go  Pretty much all that follows is run from a bash shell under Linux, Mac or Ubuntu sub system for windows. The command \u0026lsquo;jq\u0026rsquo; will be used and if it is not already installed it will also be needed :\nsudo apt install jq  With the az command installed, it is also assumed that there is already an Azure account available and that this is authenticated and ready to use with\naz login  The following is the server.go file\npackage main import ( \u0026quot;context\u0026quot; \u0026quot;fmt\u0026quot; \u0026quot;log\u0026quot; \u0026quot;net/http\u0026quot; \u0026quot;os\u0026quot; \u0026quot;os/signal\u0026quot; \u0026quot;syscall\u0026quot; \u0026quot;time\u0026quot; \u0026quot;github.com/gorilla/mux\u0026quot; \u0026quot;gopkg.in/natefinch/lumberjack.v2\u0026quot; ) func handler(w http.ResponseWriter, r *http.Request) { query := r.URL.Query() name := query.Get(\u0026quot;name\u0026quot;) if name == \u0026quot;\u0026quot; { name = \u0026quot;Guest\u0026quot; } log.Printf(\u0026quot;Received request for %s\\n\u0026quot;, name) w.Write([]byte(fmt.Sprintf(\u0026quot;Hello, %s\\n\u0026quot;, name))) } func main() { // Create Server and Route Handlers r := mux.NewRouter() r.HandleFunc(\u0026quot;/\u0026quot;, handler) srv := \u0026amp;http.Server{ Handler: r, Addr: \u0026quot;:8080\u0026quot;, ReadTimeout: 10 * time.Second, WriteTimeout: 10 * time.Second, } // Configure Logging LOG_FILE_LOCATION := os.Getenv(\u0026quot;LOG_FILE_LOCATION\u0026quot;) if LOG_FILE_LOCATION != \u0026quot;\u0026quot; { log.SetOutput(\u0026amp;lumberjack.Logger{ Filename: LOG_FILE_LOCATION, MaxSize: 500, // megabytes MaxBackups: 3, MaxAge: 28, //days Compress: true, // disabled by default }) } // Start Server go func() { log.Println(\u0026quot;Starting Server\u0026quot;) if err := srv.ListenAndServe(); err != nil { log.Fatal(err) } }() // Graceful Shutdown waitForShutdown(srv) } func waitForShutdown(srv *http.Server) { interruptChan := make(chan os.Signal, 1) signal.Notify(interruptChan, os.Interrupt, syscall.SIGINT, syscall.SIGTERM) // Block until we receive our signal. \u0026lt;-interruptChan // Create a deadline to wait for. ctx, cancel := context.WithTimeout(context.Background(), time.Second*10) defer cancel() srv.Shutdown(ctx) log.Println(\u0026quot;Shutting down\u0026quot;) os.Exit(0) }  The following is the Dockerfile which will be used to build a new docker image based on the Go application above\nFROM golang:latest as builder # Add Maintainer Info LABEL maintainer=\u0026quot;Jon Brookes \u0026lt;marshyon@gmail.com\u0026gt;\u0026quot; # Set the Current Working Directory inside the container WORKDIR /app # Copy go mod and sum files COPY go.mod go.sum ./ # Download all dependencies. Dependencies will be cached if the go.mod and go.sum files are not changed RUN go mod download # Copy the source from the current directory to the Working Directory inside the container COPY . . # Build the Go app RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o main FROM alpine:latest RUN apk --no-cache add ca-certificates WORKDIR /root/ # Copy the Pre-built binary file from the previous stage COPY --from=builder /app/main . # Expose port 8080 to the outside world EXPOSE 8080 # Command to run the executable CMD [\u0026quot;./main\u0026quot;]  Here is the directory structure for the above files:\ngo-docker-app/ ├── Dockerfile └── server.go  Create the above directory, cd into it, create the Dockerfile and server.go files as above and run :\ncd go-docker go mod init github.com/\u0026lt;your github name\u0026gt;/go-docker-app go build  A docker image is then built with :\ndocker build -t go-web-app .  The following deploy.sh script creates an Azure Web Application that serves our docker image ( ensure that the word uniquename is replaced with something unique and reflective of the intended application ) :\n#!/usr/bin/bash # replace 'uniquename' with your own unique name # define variables for repeated use in the current script export RESOURCE_GROUP=\u0026quot;uniquenameResourceGroup\u0026quot; export AZURE_REGISTRY_NAME=\u0026quot;uniquenameRegisry\u0026quot; export DOCKER_IMAGE_NAME=\u0026quot;uniquename-custom-docker-image\u0026quot; export DOCKER_IMAGE_TAG=\u0026quot;v1.0.0\u0026quot; export APP_SERVICE_PLAN_NAME=\u0026quot;uniquenameAppServicePlan\u0026quot; export APP_NAME=\u0026quot;uniquenameApplicaton\u0026quot; # this will need to be unique export APP_PORT=\u0026quot;8080\u0026quot; # this is the port number our docker image is configured to listen on # build our docker image docker build -t ${DOCKER_IMAGE_NAME} . # create a resource group into which we can store resources pertinent to this activity az group create --name ${RESOURCE_GROUP} --location \u0026quot;UK South\u0026quot; # create a private registry in order to store our docker image az acr create --name ${AZURE_REGISTRY_NAME} \\ --resource-group ${RESOURCE_GROUP} --sku Basic \\ --admin-enabled true # in order to authenticate against our newly created registry, get user name and password for this CREDENTIAL_JSON=$(az acr credential show --name ${AZURE_REGISTRY_NAME}) # the output of the credential show command will be in json format and we need to extract # - passwords .. value ( the first or second it doesn't matter which # - username ( this will be the registry name ) # the following jq commands will do this for us export REGISTRY_USERNAME=$(echo ${CREDENTIAL_JSON} | jq -r '.username') export REGISTRY_PASSWORD=$(echo ${CREDENTIAL_JSON} | jq -r \u0026quot;[.passwords][0][0]|.value\u0026quot;) # now we authenticate against our newly created docker registry docker login ${AZURE_REGISTRY_NAME}.azurecr.io --username ${REGISTRY_USERNAME} --password ${REGISTRY_PASSWORD} # tag our recently created custom docker image docker tag ${DOCKER_IMAGE_NAME} ${AZURE_REGISTRY_NAME}.azurecr.io/${DOCKER_IMAGE_NAME}:${DOCKER_IMAGE_TAG} # push our tagged image to our private registry docker push ${AZURE_REGISTRY_NAME}.azurecr.io/${DOCKER_IMAGE_NAME}:${DOCKER_IMAGE_TAG} # list our docker images az acr repository list -n ${AZURE_REGISTRY_NAME} # create an Azure App Service Plan az appservice plan create --name ${APP_SERVICE_PLAN_NAME} \\ --resource-group ${RESOURCE_GROUP} --sku B1 --is-linux # create the web app into which we will deploy our container az webapp create --resource-group ${RESOURCE_GROUP} \\ --plan ${APP_SERVICE_PLAN_NAME} --name ${APP_NAME} \\ --deployment-container-image-name ${AZURE_REGISTRY_NAME}.azurecr.io/${DOCKER_IMAGE_NAME}:${DOCKER_IMAGE_TAG} # give the application credentials which it will need to log in to our private registry az webapp config container set --name ${APP_NAME} \\ --resource-group ${RESOURCE_GROUP} \\ --docker-custom-image-name ${AZURE_REGISTRY_NAME}.azurecr.io/${DOCKER_IMAGE_NAME}:${DOCKER_IMAGE_TAG} \\ --docker-registry-server-url https://${AZURE_REGISTRY_NAME}.azurecr.io \\ --docker-registry-server-user ${REGISTRY_USERNAME} \\ --docker-registry-server-password ${REGISTRY_PASSWORD} # configure environment variables for the docker instance az webapp config appsettings set --resource-group ${RESOURCE_GROUP} --name ${APP_NAME} --settings WEBSITES_PORT=${APP_PORT}  The application should now be available at\nhttp://${APP_NAME}.azurewebsites.net  References :  Building Docker Containers for Go Applications Tutorial: Build a custom image and run in App Service from a private registry  "
},
{
	"uri": "https://marshyon.github.io/marshyon/getting-started/installation/",
	"title": "Installation",
	"tags": [],
	"description": "",
	"content": " The following steps are here to help you initialize your new website. If you don\u0026rsquo;t know Hugo at all, we strongly suggest you learn more about it by following this great documentation for beginners.\nCreate your project Hugo provides a new command to create a new website.\nhugo new site \u0026lt;new_project\u0026gt;  Install the theme Install the Hugo-theme-learn theme by following this documentation\nThis theme\u0026rsquo;s repository is: https://github.com/matcornic/hugo-theme-learn.git\nAlternatively, you can download the theme as .zip file and extract it in the themes directory\nBasic configuration When building the website, you can set a theme by using --theme option. However, we suggest you modify the configuration file (config.toml) and set the theme as the default. You can also add the [outputs] section to enable the search functionality.\n# Change the default theme to be use when building the site with Hugo theme = \u0026quot;hugo-theme-learn\u0026quot; # For search functionality [outputs] home = [ \u0026quot;HTML\u0026quot;, \u0026quot;RSS\u0026quot;, \u0026quot;JSON\u0026quot;]  Create your first chapter page Chapters are pages that contain other child pages. It has a special layout style and usually just contains a chapter name, the title and a brief abstract of the section.\n### Chapter 1 # Basics Discover what this Hugo theme is all about and the core concepts behind it.  renders as\nHugo-theme-learn provides archetypes to create skeletons for your website. Begin by creating your first chapter page with the following command\nhugo new --kind chapter basics/_index.md  By opening the given file, you should see the property chapter=true on top, meaning this page is a chapter.\nBy default all chapters and pages are created as a draft. If you want to render these pages, remove the property draft: true from the metadata.\nCreate your first content pages Then, create content pages inside the previously created chapter. Here are two ways to create content in the chapter:\nhugo new basics/first-content.md hugo new basics/second-content/_index.md  Feel free to edit thoses files by adding some sample content and replacing the title value in the beginning of the files.\nLaunching the website locally Launch by using the following command:\nhugo serve  Go to http://localhost:1313\nYou should notice three things:\n You have a left-side Basics menu, containing two submenus with names equal to the title properties in the previously created files. The home page explains how to customize it by following the instructions. When you run hugo serve, when the contents of the files change, the page automatically refreshes with the changes. Neat!  Build the website When your site is ready to deploy, run the following command:\nhugo  A public folder will be generated, containing all static content and assets for your website. It can now be deployed on any web server.\nThis website can be automatically published and hosted with Netlify (Read more about Automated HUGO deployments with Netlify). Alternatively, you can use Github pages\n "
},
{
	"uri": "https://marshyon.github.io/marshyon/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://marshyon.github.io/marshyon/",
	"title": "My New Hugo Site",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://marshyon.github.io/marshyon/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]